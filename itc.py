# -*- coding: utf-8 -*-
"""ITC.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1THEsJm-D0RaREH95deMfB5Aq2J7ZvyS-

# Linear Ragression

### Model building
"""

import numpy as np

class GradientDescentLinearRegression:
    
    def __init__(self, learning_rate=0.01, iterations=1000):
        self.learning_rate, self.iterations = learning_rate, iterations
       
    
    def fit(self, X, y):
        b = 0
        m = 5
        loss = []
        ms = []
        bs = []
        n = X.shape[0]
        for _ in range(self.iterations):
            loss.append(np.sum((y-(m*X+b))**2))
            ms.append(m)
            bs.append(b)
            b_gradient = -2 * np.sum(y - (m*X + b))/n
            m_gradient = -2 * np.sum(X*(y - (m*X + b)))/n
            b = b - (self.learning_rate * b_gradient)
            m = m - (self.learning_rate * m_gradient)
        self.m, self.b = m, b
        self.loss = np.array(loss)
        self.ms = np.array(ms)
        self.bs=np.array(bs)
        
    def predict(self, X):
        return self.m*X + self.b

"""### Data generation"""

np.random.seed(103)
X = np.array(sorted(list(range(5))*20)) + np.random.normal(size=100, scale=0.5)
y = np.array(sorted(list(range(5))*20)) + np.random.normal(size=100, scale=0.25)

"""### Data Visualisation"""

import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
plt.scatter(X, y, color='black')

"""### Model training"""

clf = GradientDescentLinearRegression()
clf.fit(X, y)

import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')

plt.scatter(X, y, color='black')
plt.plot(X, clf.predict(X))
plt.gca().set_title("Gradient Descent Linear Regressor")

plt.plot(clf.ms, clf.loss)

"""### (More)

"""

from numpy import random
import matplotlib.pyplot as plt
import seaborn as sns

sns.distplot(random.normal(size=1000,scale=0.25), hist=False)

plt.show()

"""# Decision Tree

### Preparing data
"""

import pandas as pd
import numpy as np
from sklearn.tree import DecisionTreeClassifier 
from sklearn.model_selection import train_test_split 
from sklearn import metrics

# Loading Data
df = pd.read_csv("diabetes.csv")

df.head()

# Features and labels selection
x = df.drop(columns='Outcome',axis=1)
feature_cols = x.columns
X = df[feature_cols]
Y = df['Outcome']
labels = ['0', '1']

# Splitting data
x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, stratify=Y, random_state=1)

"""### Building Decision Tree Model"""

# Create Decision Tree classifer object
clf = DecisionTreeClassifier(criterion="entropy",max_depth=8)

# Train Decision Tree Classifer
clf = clf.fit(x_train,y_train)

# Predict the response for test dataset
y_pred = clf.predict(x_test)

# Evaluation
print(metrics.accuracy_score(y_test, y_pred))

"""### Visualizing Decision Tree"""

import matplotlib.pyplot as plt
from sklearn import tree
plt.figure(figsize=(30,10))
a = tree.plot_tree(clf, feature_names=feature_cols, class_names=labels, rounded = True, filled = True, fontsize=14)
plt.show()

"""# K-means

### Preparing Data
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
# %matplotlib inline
import seaborn as sns

#Create data frame
df = pd.read_csv('kmeans_blobs.csv')
df.head()

"""### Data Visualisation"""

sns.scatterplot(x='x', y='y', data = df)

"""### Running K-means"""

from scipy.cluster.vq import kmeans, vq,whiten

#Generate cluster centers 
cluster_centers, distortion = kmeans(obs=df[['x','y']],k_or_guess=4)

#Generate cluster labels
df['cluster'], distortion_list = vq(df[['x','y']],cluster_centers)

df.head(10)

sns.scatterplot(x='x', y='y', 
                hue='cluster', data = df)

print(distortion)

"""### Elbow method"""

distortions = []
num_clusters = range(1, 7)

# Create a list of distortions from the kmeans function
for i in num_clusters:
    cluster_centers, distortion = kmeans(df[['x', 'y']], i)
    distortions.append(distortion)

# Create a DataFrame with two lists - num_clusters, distortions
elbow_plot = pd.DataFrame({'num_clusters': num_clusters,'distortions': distortions})

sns.lineplot(x='num_clusters', y='distortions',data = elbow_plot)